--- 
name: wisp-of-lisp
layout: blogger_post
title: A wisp of Lisp
thumbnail: http://lisperati.com/lisplogo_warning_128.png
time: 2007-05-27 22:43:00 +05:30
tags: [computers]
---
Lisp is a funny looking language, with a scary deluge of parantheses. Some of you might know it as Scheme (it's different, but not very). I had loved it in college days - the Lisp questions were all like puzzles, and all you had to do to solve them was keep recursion in mind (efficiency can go to hell), and most importantly, none in my class <span style="font-style: italic;">loved</span> it, or that's what I think - many could barely stand it. I remember a particular class test since it was probably the only one I actually enjoyed writing: it had ten questions each of which required you to write a small Lisp program that did arcane stuff like computing x power y and inserting into a list and stuff. <br /> <br />Now that's a surprise since I abhorred (and still abhor) the idea of "writing" a program on paper, however trivial the problem. I think if I had to write a program to do the same arcane stuff in C or <span style="font-style: italic;">insert your favourite language here</span>, I wouldn't have been comfortable vouching for a program I "wrote" straight on paper. But with Lisp, all you had to do was write something like the equivalent of a mathematical expression that describes the functionality, and you're done. Talk about succinctness. In fact, I think unless it's a lab test, "Write a program to ..." questions are unfair in any other computer language - for the examinee to solve perfectly or for the examiner to verify without doubt. Too tedious to do either. <br /> <br /> 
<div> 
<a onblur="try {parent.deselectBloggerImageGracefully();} catch(e) {}" href="http://lisperati.com/casting.html"><img style="margin: 0px auto 10px; display: block; text-align: center; cursor: pointer;" src="http://lisperati.com/different.jpg" alt="" border="0" /></a> 
<small>Image source: <a href="http://lisperati.com/">Lisperati</a></small> <br/> 
</div> 
I read up on the background behind why Lisp is so like math only last weekend, prompted by Penrose's <span style="font-style: italic;">The Emperor's New Mind</span>. The history starts with Hilbert's decision problem, put forth in completion in 1928. Hilbert <a href="http://en.wikipedia.org/wiki/Entscheidungsproblem">asked</a> for a general algorithm that could take in an algebraic conjecture (like, say: it's <a href="http://en.wikipedia.org/wiki/Catalan%27s_conjecture">impossible</a> to find integer values for x, y, a,b such that (<i>x+3)</i><sup><i>a</i></sup> − <i>y</i><sup><i>b</i></sup> = 1 for <i>x, y, a, b > 1</i>) and say whether the conjecture is true or false. While many solutions exist for <a href="http://en.wikipedia.org/wiki/Diophantine_equation">problems</a> of such nature, there are many conjuctures that are unsolved. So asking for a general algorithm for this is a tall order, and as it turned out, it was proved that it is impossible to find one, using three completely different methods, respectively by three different people: Gödel, Turing and Church. Lisp borrows heavily from the methods that the last two invented for their counterproofs. <br /> <br />Turing's approach (published 1936) was to imagine a machine to solve each conjecture - much like how one would write a program to fit all sorts of values to x, y, a and b to see if (<i>x+3)</i><sup><i>a</i></sup> − <i>y</i><sup><i>b</i></sup> is 1. So, you could have one Turing machine (say T<sub>C</sub>) that tries to solve this (<i>x+3)</i><sup><i>a</i></sup> − <i>y</i><sup><i>b</i></sup> business of <a href="http://en.wikipedia.org/wiki/Catalan%27s_conjecture">Catalan's</a> conjecture and another (say T<sub>G</sub>) that works on <a href="http://en.wikipedia.org/wiki/Goldbach%27s_conjecture">Goldbach's</a> conjecture, and so on. If T<sub>C</sub> will come to a stop sometime, we will have a solution for <i>(x+3)</i><sup><i>a</i></sup> − <i>y</i><sup><i>b</i></sup> = 1,  and would have proved Catalan wrong. If it's gonna run forever, well, then we'll know Catalan was right after all. <br /> <br />Now, if a machine could take on conjectures like this using a standard set of instructions, those instructions themselves can surely be passed as input to a Turing machine. We can imagine Turing machines that can take in the "software" of particular turing machines as input, and make use of that. The most straightforward of these would be the Universal Turing machine (T<sub>U</sub>). If you pass  to T<sub>U</sub> the "software" of T<sub>C</sub>, T<sub>U</sub> would then act like T<sub>C</sub> till it<sub></sub> comes to an end. This is not unlike the Perl interpreter, that can run either your T<sub>G</sub> program or the T<sub>C</sub> program or whatever program. <br /> <br />Turing used the concept of Turing machines capable of taking in as input a set of instructions to reinterpret Hilbert's original problem. Turing reduced the decision problem to finding a Turing machine that could take in the "software" of a particular Turing machine, and say (in finite time) whether that Turing machine will complete in finite time, or not. (If you're imagining a code-analyzer for Perl programs, note that it's not just sufficient to check for semantic errors like infinite loops and the like - T<sub>C</sub> will never complete, even if it's programmed perfectly.) <br /> <br /> 
<div class="imageleft"> 
<a href="http://lisperati.com/casting.html"><img src="http://lisperati.com/lisplogo_warning_128.png" alt="" border="0" /></a> <br/> 
<small>Source: <a href="http://lisperati.com/">Lisperati</a></small> 
</div> 
Now, Lisp (short for List processor), is a mechanism for dealing with lists. A list is a simple and scalable representation of data, especially if it can accomodate other lists as members. If you use parantheses to <samp>(enclose lists and (lists of lists) like this)</samp>, no doubt you see a hell lot of parantheses on Lisp programs. But this also offers a way of thinking of programs as lists - the first element in the list is an operator, like <samp>+</samp> or <samp>append</samp>, that can act on the other elements in the list, like <samp>(+ 41 1)</samp>. <br /> <br />A list processor should have some basic list operators (like <samp>get_first_element</samp> and <samp>get_length</samp> and so on). We can map these operators to individual Turing machines. And while there are Turing machines, we can very well envisage a Universal Turing machine Lisp operator that could take in a program (represented as a list), and produce the result of that program. Given the basic list processing infrastructure that was Lisp in 1958, it was suprisingly <a href="http://lib.store.yahoo.net/lib/paulgraham/jmc.ps">easy</a> to formulate an <samp>eval</samp> function, written using the existing list processing infrastructure, that could act as the Lisp-equivalent of the Universal Turing machine. Well, if you actually think about it, this Lisped T<sub>U</sub> is actually a Lisp interpreter, since it can take in a Lisp program, and execute it. And, lo!, you have a new working programming language. <br /> <br />And that's why it's so much like math. And it's probably because of it's likeness to abstract mathematics that it's still <span style="font-style: italic;">the</span> language whose programs can be simultaneously readable and succinct. Let's see if Paul Graham, it's all-time-<a href="http://www.paulgraham.com/icad.html">fanatic</a> can actually give it a new lease of <a href="http://www.paulgraham.com/arc.html">life</a>.<div class="blogger-post-footer"><img width='1' height='1' src='https://blogger.googleusercontent.com/tracker/5850977-1772807334962216538?l=roop.blogspot.com' alt='' /></div> 
